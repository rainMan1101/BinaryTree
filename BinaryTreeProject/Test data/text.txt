Спасибо за память
Изучаем, как JVM использует системную память в Windows и Linux

"Куча", в которой выделяется место для каждого объекта в Java, - это область памяти, с которой разработчик при написании Java-приложения контактирует наиболее тесно. JVM была спроектирована таким образом, чтобы изолировать нас от внутренностей операционной системы, поэтому когда идет речь о памяти, естественно думать о куче Java. Несомненно, вы сталкивались с исключением OutOfMemoryError , вызванным утечкой объектов или тем, что размер кучи был задан недостаточно большим для того, чтобы вместить все ваши данные, и возможно даже изучили несколько приемов отладки подобных сценариев. Но по мере увеличения нагрузки и объема данных, обрабатываемых приложением, могут начать появляться исключения OutOfMemoryError которые нельзя устранить с помощью стандартных приемов. Такие исключения возникают даже тогда, когда в куче Java есть свободное место. Чтобы понять, что происходит, необходимо разобраться в том, как работает исполняющая среда Java (JRE).

Приложения Java запускаются в виртуальном окружении исполняющей среды Java, а сама исполняющая среда является программой, написанной на таком языке как C, использующей ресурсы операционной системы, в том числе системную память. Системная память – это память, доступная для процесса исполняющей среды, а память в куче Java – это память, используемая приложением Java. В системной памяти хранятся все виртуальные ресурсы приложения Java, такие как куча и потоки, а также данные, необходимые для работы самой виртуальной машины. Это значит, что ограничения системной памяти, накладываемые аппаратным обеспечением и операционной системой (ОС), влияют на возможности приложения.

Это одна из двух статей, раскрывающих одну и ту же тему для разных платформ. Из обеих статей вы узнаете о том, что такое системная память, как исполняющая среда Java ее использует, как выглядят ситуации с нехваткой системной памяти и как отлаживать подобные исключения OutOfMemoryError. В данной статье эта тема рассматривается для операционных систем Windows и Linux без акцента на какой-либо конкретной исполняющей среде. Во второй статье проблема рассматривается для случая операционной системы AIX и IBM® Developer Kit для Java. (Приводимая в ней информация о реализации исполняющей среды Java от IBM также справедлива и для платформ отличных от AIX. Поэтому если вы используете IBM Developer Kit для Java на Linux или 32-разрядную исполняющую среду Java от IBM для Windows, вторая статья вам также может оказаться полезной.

Обзор устройства системной памяти
Я начну с рассказа о том, какие ограничения на физическую память накладываются операционной системой и аппаратным обеспечением. Если вы знакомы с управлением динамической памятью в таком языке как C, вы можете сразу перейти к следующему разделу.

Аппаратные ограничения
Многие накладываемые на процесс ограничения обусловлены аппаратным обеспечением, а не операционной системой. Каждый компьютер имеет процессор и некоторое количество памяти произвольного доступа (RAM), также называемой физической памятью. Процессор интерпретирует поток данных как инструкции для выполнения, он имеет один или несколько обрабатывающих блоков, выполняющих целочисленные вычисления, вычисления с плавающей точкой, а также более сложные вычисления. Процессор имеет определенное количество регистров – очень быстрых элементов памяти, используемых для хранения данных при выполнении вычислений. Размер регистра определяет максимальное число, которое процессор может использовать в отдельном вычислении.

Процессор соединяется с физической памятью посредством шины памяти. Количество памяти, к которой можно обращаться, ограничено размером физического адреса (адреса, используемого процессором для указания на физическую память). Например, 16-разрядный адрес может указывать на адреса от 0x0000 до 0xFFFF, что составляет 2^16 = 65536 уникальных участков памяти. Если каждый адрес указывает на блок памяти размером 1 байт, 16-разрядный физический адрес позволяет процессору адресовать 64КБ памяти.

Процессоры классифицируют по количеству бит (разрядов). Как правило, это количество обозначает размер регистров процессора, хотя есть и исключения – например 31-разрядная система 390 – где 31 разряд обозначает размер физического пространства адресов. Для рабочих станций и серверных платформ это число обычно равно 31, 32 или 64, а для встроенных устройств и микропроцессоров оно может снижаться до 4. Размер физического адреса может совпадать с размером регистра, хотя может быть как больше, так и меньше его. Большинство 64-разрядных процессоров могут выполнять 32-разрядные программы, если они находятся под управлением подходящей операционной системы.

В таблице 1 перечислены размеры регистров и физических адресов для некоторых популярных архитектур Windows и Linux:

Операционные системы и виртуальная память
Если бы вы писали приложение, работающее непосредственно на процессоре без участия операционной системы, вы бы могли использовать всю память, которую процессор может адресовать (если предположить, что имеется достаточное количество физической RAM-памяти). Но, для того, чтобы иметь удовольствие воспользоваться такими возможностями, как многозадачность и аппаратные абстракции, почти все используют для выполнения своих программ какую-либо операционную систему.

В многозадачной ОС, такой как Windows или Linux системные ресурсы, в том числе и память, используются больше, чем одной программой. Каждой программе необходимо выделить для работы участки физической памяти. Можно спроектировать такую операционную систему, в которой каждой программе будет разрешено работать с выделенной ей физической памятью напрямую, и некоторые встроенные операционные системы работают именно таким образом. Однако это не очень практично в окружении, состоящем из множества программ, совместная работа которых не протестирована, так как любая программа может повредить память, используемую другой программой или самой операционной системой.

Виртуальная память позволяет множеству процессов совместно использовать физическую память, не давая возможность повредить чужие данные. В операционных системах с виртуальной памятью (таких как Windows, Linux и множество других) каждая программа имеет свое собственное виртуальное адресное пространство – логический участок адресов, размер которых определяется размером адресов операционной системы (т.е. 31, 32 или 64 бита для рабочей станции или серверной платформы). Виртуальное адресное пространство процесса может отображаться в физическую память, файл или какое-либо другое устройство хранения. Операционная система может перемещать данные из физической памяти в область подкачки (файл подкачки в Windows или раздел подкачки в Linux) и, при необходимости, наоборот, для обеспечения наилучшего использования физической памяти. Когда программа запрашивает память по виртуальному адресу, операционная система при содействии аппаратного обеспечения определяет физическое местонахождение виртуального адреса. Адрес может находиться в физической RAM-памяти, файле или разделе/файле подкачки. Если запрошенный участок памяти ранее был перемещен в область подкачки, то перед использованием он загружается обратно в физическую память. На рисунке 1 показано, как работает виртуальная память, отображая участки адресного пространства процесса на совместно используемые ресурсы:

Рисунок 1. Отображение адресного пространства процесса посредством виртуальной памяти в физические ресурсы
Virtual memory mapping
Каждая программа выполняется в виде процесса. В Windows и Linux процесс представляет собой коллекцию информации об управляемых операционной системой ресурсах (таких, как информация о файле или сокете), как правило, одном виртуальном адресном пространстве (на некоторых архитектурах более чем одном), и как минимум одном потоке выполнения.

Размер виртуального адресного пространства процесса может быть меньше, чем физическое адресное пространство процессора. 32-разрядная архитектура Intel x86 изначально имела 32-разрядный физический адрес, позволявший процессору адресовать 4ГБ памяти. Позднее была добавлена возможность расширения физических адресов (PAE или Physical Address Extension), которая расширяет размер физического адресного пространства до 36 разрядов и позволяет устанавливать и адресовать до 64ГБ памяти RAM. PAE позволяет операционным системам отображать 32-разрядные виртуальные адресные пространства размером 4ГБ на большие интервалы физических адресов, но не позволяет каждому процессу иметь адресное пространство размером 64 ГБ. Это значит, что если вы установите более 4ГБ памяти в 32-разрядный сервер Intel, вы не сможете работать напрямую со всей памятью в рамках одного процесса.

Функциональность AWE (Address Windowing Extensions или расширения адресных окон) позволяет процессу в Windows отображать часть своего 32-разрядного адресного пространства в виде скользящего окна в область памяти большего размера. Linux использует подобную технологию для отображения участков памяти в виртуальное адресное пространство. Это значит, что хотя напрямую адресовать более 4ГБ памяти нельзя, работа с участками памяти большего размера все же возможна.

Пространство ядра и пространство пользователя
Хотя каждый процесс имеет свое собственное адресное пространство, как правило, программа не может использовать его полностью. Адресное пространство разделяется на пространство пользователя и пространство ядра. Ядро – это главная программа операционной системы, предоставляющая средства взаимодействия с аппаратным обеспечением, программами-планировщиками, а также такие сервисы как сеть и виртуальная память.

В рамках процесса загрузки компьютера операционная система запускает и инициализирует аппаратное обеспечение. После того, как ядро сконфигурирует аппаратное обеспечение и свое внутренне состояние, запускается первый процесс пользовательского пространства. Если пользовательская программа нуждается в услугах операционной системы, она может выполнить операцию, называемую системным вызовом, которая "перескакивает" в ядро и выполняет запрошенные действия. Системные вызовы обычно требуются для таких операций как чтение и запись файлов, сетевые операции и запуск новых процессов.

При выполнении системного вызова ядру необходим доступ к своей собственной памяти, а также к памяти вызывающего процесса. Процессор, выполняющий текущий поток, сконфигурирован для отображения виртуальных адресов с помощью адресного пространства текущего процесса. Поэтому в большинстве ОС часть адресного пространства каждого процесса отображается в общий участок памяти ядра. Эта часть адресного пространства называется пространством ядра, а остальная часть, которая может быть использована пользовательским приложением, называется пространством пользователя.

Баланс между пространством пользователя и пространством ядра различается в разных операционных системах и даже для одной операционной системы, работающей на разных архитектурах. Это соотношение зачастую можно конфигурировать и выделять больше места для пользовательских приложений или ядра. Сокращение области ядра может вызывать такие проблемы, как ограничение количества одновременно находящихся в системе пользователей, или количества запущенных процессов. Меньший размер пространства пользователя означает, что разработчик приложения имеет меньше рабочего места.

По умолчанию 32-разрядная система Windows имеет 2ГБ пространства пользователя и 2ГБ пространства ядра. В некоторых версиях Windows размер пространства пользователя можно увеличить до 3ГБ и соответственно уменьшить пространство ядра до 1ГБ, добавив переключатель /3GB в конфигурацию загрузки и перекомпоновав приложения с переключателем /LARGEADDRESSAWARE. На 32-разрядных системах Linux пространство пользователя по умолчанию имеет размер 3ГБ, а пространство ядра – 1ГБ. Некоторые дистрибутивы Linux предоставляют ядро hugemem, поддерживающее 4ГБ пользовательского пространства. Для достижения этого ядру выделяется свое собственное адресное пространство, используемое при выполнении системных вызовов. За преимущества, использования большого пользовательского пространства приходится платить более медленными системными вызовами. Операционной системе приходится копировать данные между адресными пространствами и сбрасывать отображения адресного пространства процесса каждый раз при выполнении системного вызова. На рисунке 2 показана разметка адресного пространства 32-разрядной системы Windows:

Рисунок 2. Разметка адресного пространства 32-разрядной системы Windows
Windows 32 bit address spaces
На рисунке 3 показана структура адресного пространства на 32-разрядных системах Linux:

Рисунок 3. Разметка адресного пространства 32-разрядной системы Linux
Linux 32 bit address spaces
Отдельное адресное пространство ядра также используется в 31-разрядной системе Linux 390. Здесь разделение небольшого (2-гигабайтного) адресного пространства является нежелательным, однако архитектура 390 может одновременно работать с несколькими адресными пространствами без издержек производительности.

Адресное пространство процесса должно содержать в себе все, что нужно программе, в том числе саму программу и используемые ей разделяемые библиотеки (.dll для Windows и .so файлы для Linux). Разделяемые библиотеки не только забирают свободное пространство у программы, они также могут фрагментировать адресное пространство и уменьшать количество памяти, которую можно выделить в виде непрерывного блока. Это становится заметным в программах, работающих на Windows x86 с 3ГБ пользовательского пространства. DLL-библиотеки устроены таким образом, что при загрузке они отображаются в память адресного пространства, расположенную по заранее определенному адресу, если он не занят. Если же адрес занят, то они перебазируются в какое-либо другое место. При проектировании Windows NT, в котором пользовательское пространство имело размер 2ГБ, имело смысл размещать системные библиотеки вблизи границы двух гигабайт, оставляя, таким образом, большую часть пользовательской памяти свободной для использования приложением. Но при расширении пространства пользователя до 3ГБ, системные разделяемые библиотеки все также загружаются на границе 2ГБ, теперь уже в середине адресного пространства. Поэтому, хотя общий размер пространства пользователя составляет 3ГБ, невозможно выделить непрерывный блок памяти размером 3ГБ.

Использование переключателя /3GB в Windows сокращает размер адресного пространства ядра наполовину. В некоторых сценариях 1ГБ пространства ядра может полностью исчерпаться, что чревато замедлением операций ввода/вывода или проблемами при создании пользовательских сеансов. Хотя переключатель /3GB может быть чрезвычайно полезен в некоторых приложениях, для любого окружения, в котором он будет использоваться, следует провести тщательное нагрузочное тестирование перед разворачиванием приложения. Больше информации о переключателе /3GB, его достоинствах и недостатках, вы можете найти по ссылке в разделе Ресурсы.

Утечки системной памяти или чрезмерное использование системной памяти приводят к различным проблемам в зависимости от того, что закончится раньше: адресное пространство или физическая память. Исчерпание адресного пространства обычно происходит только с 32-разрядными процессами, так как максимум в 4ГБ довольно легко использовать полностью. 64-разрядные процессы имеют адресное пространство размером в сотни или тысячи гигабайт, которое сложно заполнить полностью, даже если постараться. При исчерпании адресного пространства процесса Java исполняющая среда Java начинает проявлять странные симптомы, описываемые далее в этой статье. При работе в системе, где размер адресного пространства превышает размер физической памяти, утечки памяти или чрезмерное использование системной памяти принуждают операционную систему перемещать определенную часть адресного пространства процесса в область подкачки. Доступ к адресу памяти, находящемуся в области подкачки, осуществляется гораздо медленнее, чем чтение резидентного (находящегося в физической памяти) адреса, так как в этом случае операционная система должна считать данные с жесткого диска. Могут возникать ситуации, когда заканчивается и вся физическая память, и область подкачки. В Linux это приводит к срабатыванию функции ядра OOM (out-of-memory)-killer, которая принудительно завершает процесс, использующий наибольшее количество памяти. В Windows это приводит к сбоям выделения памяти, точно также как в случае исчерпания адресного пространства.

Если вы пытаетесь использовать больше виртуальной памяти, чем имеющееся количество физической памяти, проблема станет проявляться задолго до того, как процесс будет принудительно завершен. Система начнет "метаться" и большая часть времени будет уходить на копирование данных в область подкачки и из нее. Когда это происходит, производительность компьютера и отдельных приложений становится настолько плохой, что пользователь не сможет не заметить проблему. Когда куча памяти Java перемещается в область подкачки, производительность сборщика мусора становится настолько ужасной, что порой может казаться, что приложение зависло. Если на одной машине одновременно работают несколько исполняющих сред Java, физической памяти должно быть достаточно для размещения всех куч памяти Java.

Как исполняющая среда Java использует системную память
Исполняющая среда Java – это процесс операционной системы, на который действуют ограничения аппаратного обеспечения и операционной системы, о которых я рассказал в предыдущем разделе. Исполняющая среда обеспечивает средства работы, предоставляемые какому-то неизвестному пользовательскому коду. Поэтому невозможно предсказать, какие ресурсы потребуются исполняющей среде в каждой ситуации. Каждое действие, предпринимаемое приложением Java в управляемом окружении Java, потенциально может повлиять на требования к ресурсам, получаемым посредством исполняющей среды. В этом разделе рассказывается, как и почему приложения Java используют системную память.

Куча памяти Java и сборка мусора
Куча в Java – область памяти, в которой происходит выделение места для всех объектов приложения. Большинство реализаций Java SE имеют одну логическую кучу, хотя некоторые специальные исполняющие среды Java, например реализующие спецификацию Java реального времени (Real Time Specification for Java или RTSJ), имеют несколько куч. Одна физическая куча может быть разбита на разделы, в зависимости того, какой алгоритм сборки мусора (garbage collection или GC) используется для управления памятью кучи. Эти разделы обычно реализуются как непрерывные участки системной памяти, находящиеся под управлением менеджера памяти Java (который включает в себя сборщика мусора).

Размером кучи можно управлять из командной строки с помощью параметров -Xmx и -Xms (mx – определяет максимальный размер кучи, ms - изначальный размер). Хотя логическая куча (активно используемая область памяти) может расти и уменьшаться в зависимости от количества находящихся в куче объектов и от работы сборщика мусора, количество используемой системной памяти остается постоянным и зависит от значения -Xmx, задающего максимальный размер кучи. Большинство алгоритмов сборки мусора полагаются на то, что куча представляет собой непрерывный участок памяти, поэтому после создания кучи увеличить ее размер уже невозможно. Вся память кучи должна быть зарезервирована заранее.

Резервирование системной памяти это не то же самое, что ее выделение. При резервировании системной памяти не выделяется какой-либо физической памяти. Хотя выделение блоков адресного пространства не приведет к исчерпанию физических ресурсов, оно не позволяет использовать эту память для других целей. Утечка, вызванная резервированием никогда не используемой памяти также серьезна, как и утечка выделенной памяти.

Некоторые сборщики мусора минимизируют использование физической памяти, освобождая неиспользуемые участки памяти, при уменьшении размера кучи.

Также системная память необходима для поддержки состояния системы управления памятью, контролирующей кучу Java. При сборке мусора необходимо выделять память для структур данных, отслеживающих свободные участки памяти и записывающих прогресс работы. Точный размер и природа этих структур данных зависят от реализации, но размер многих из них пропорционален размеру кучи.

Just-in-time (JIT) компилятор
Компилятор JIT во время выполнения программы компилирует байткод Java в оптимизированный выполняемый платформенно-зависимый код. Это очень ускоряет работу исполняющей среды Java и позволяет приложениям Java выполняться на скорости, сравнимой с платформенно-зависимым кодом.

Также как для работы обычного статического компилятора, такого как gcc, для компиляции байткода требуется системная память, но, кроме того, также входные (байткод) и выходные данные (исполняемый код) компилятора JIT также должны храниться в системной памяти. Приложения Java, содержащие много JIT-скомпилированных методов используют больше системной памяти, чем менее крупные приложения.

Классы и загрузчики классов
Приложения Java состоят из классов, которые определяют структуры объектов и логику методов. Кроме того, они используют классы библиотеки Java (такие как java.lang.String), а также могут использовать сторонние библиотеки. Пока эти классы используются, они должны храниться в памяти.

То, каким образом хранятся классы, зависит от реализации. В JDK от Sun используется область кучи PermGen (permanent generation или постоянного порождения). В реализации Java 5 от IBM для хранения каждого загрузчика класса и самого класса заранее выделяется блок системной памяти. В современных исполняющих средах Java имеются технологии такие, как совместное использование классов, которые могут требовать отображения областей разделяемой памяти в адресное пространство. Чтобы понять, как эти технологии влияют на использование системной памяти в вашей реализации исполняющей среды Java, нужно читать техническую документацию исполняющей среды. Однако есть универсальные закономерности, работающие во всех реализациях.

На самом простом уровне, больше классов используют больше памяти. (Это может значить как то, что использование системной памяти просто будет расти, так и то, что вам придется явно переопределить размер области памяти – такой как PermGen или кэш разделяемых классов, чтобы вместить все нужные классы.) Помните, что место необходимо не только вашему приложению: инфраструктуры, серверы приложений, сторонние библиотеки и сама исполняющая среда Java содержат классы, загружаемые по требованию и занимающие место.

Исполняющая среда Java может выгружать ненужные классы для освобождения места, но только при выполнении довольно строгих условий. Невозможно выгрузить отдельный класс; выгружаются только загрузчики вместе со всеми своими загруженными классами. Загрузчик класса может быть выгружен только если:

Куча Java не содержит ссылок на объект java.lang.ClassLoader представляющий этот загрузчик класса.
Куча Java не содержит ссылок на объекты java.lang.Class представляющие классы, загруженные этим загрузчиком.
Куча Java не содержит ни одной ссылки на объекты классов, загруженные этим загрузчиком
Стоит заметить, что три загрузчика классов по умолчанию, которые исполняющая среда Java создает для всех приложений, — bootstrap, extension и application никогда не могут отвечать этим критериям. Поэтому все системные классы (такие как java.lang.String) или любые классы приложения, загруженные с помощью загрузчика application , не могут быть выгружены во время выполнения.

Даже когда загрузчик класса может быть удален, это происходит только как часть цикла сборки мусора. В некоторых реализациях выгрузка классов осуществляется лишь на некоторых циклах сборки мусора.

Также классы могут генерироваться во время выполнения без вашего участия. Многие приложения J2EE используют технологию JavaServer Pages (JSP) для создания Web-страниц. Инфраструктура JSP генерирует класс для каждой выполняемой .jsp страницы, который существует все время жизни загрузившего его загрузчика класса, обычно совпадающее со временем жизни всего Web-приложения.

Другой распространенный способ генерации классов Java – с помощью отражения (reflection). Механизм отражения в разных реализациях Java работает по-разному, но в реализациях от Sun и IBM используется метод, о котором я сейчас расскажу.

При использовании API java.lang.reflect исполняющая среда Java должна соединить методы отражающего объекта (такого как java.lang.reflect.Field) с объектом или классом, на который осуществляется отражение. Это может реализовываться с помощью метода доступа к атрибутам класса (аксессора) Java Native Interface (JNI), который почти не требует настройки, но довольно медлителен в работе, или посредством динамического построения класса во время выполнения для каждого объекта, на который вы хотите осуществить отражение. Последний метод требует длительной настройки, но работает быстрее, что делает его идеальным для приложений, часто осуществляющих отражение на определенный класс.

Для отражения класса первые несколько раз исполняющая среда Java использует метод чтения (аксессор) JNI. После нескольких раз использования этот аксессор может "дорасти" до аксессора байткода, создание которого включает в себя построение класса и его загрузку посредством нового загрузчика. Частое применение отражений может привести к созданию множества классов доступа и загрузчиков классов. Хранение ссылок на отражающие объекты приводит к тому, что эти классы остаются в памяти и продолжают занимать место. Так как создание аксессоров байткода – довольно медленная операция, исполняющая среда Java может кэшировать эти аксессоры для последующего использования. Также объекты отражения могут кэшироваться в приложениях и инфраструктурах, что еще больше увеличивая использование системной памяти.

JNI
JNI позволяет платформенно-зависимому коду (приложениям, написанным на таких языках, как C и C++) вызывать методы Java, а также наоборот. Исполняющая среда Java сама по себе в значительной степени полагается на код JNI при реализации некоторых функций библиотеки классов, обеспечивающих, например файловый и сетевой ввод/вывод. Использование системной памяти средой выполнения Java может увеличиваться за счет приложения JNI тремя способами:

Платформенно-зависимый код для приложения JNI компилируется в разделяемую библиотеку или исполняемый файл, загружаемый в адресное пространство процесса. Большие платформенно-зависимые приложения только лишь от того, что они загружены, могут занимать значительные участки адресного пространства процесса.
Платформенно-зависимый код должен разделять адресное пространство с исполняющей средой Java. Любое выделение системной памяти или отображение памяти, выполняемое платформенно-зависимым кодом, забирает память у исполняющей среды Java.
Некоторые функции JNI могут в своей работе использовать системную память. Функции GetTypeArrayElements и GetTypeArrayRegion могут копировать данные из кучи Java в буферы системной памяти для обработки платформенно-зависимым кодом. Делается ли копия данных или нет – зависит от реализации исполняющей среды (IBM Developer Kit для Java 5.0 и выше делают платформенно-зависимую копию). Доступ подобным образом к большим объемам данных из кучи Java может требовать также пропорционально большого количества системной памяти.
NIO
Новые классы ввода/вывода NIO (new I/O), добавленные в Java 1.4, представляют собой новый способ осуществления ввода/вывода, основанный на каналах и буферах. Наряду с буферами ввода/вывода основанными на памяти в куче Java, в NIO есть поддержка прямых объектов ByteBuffer (выделяемых с помощью метода java.nio.ByteBuffer.allocateDirect()), основанных на использовании напрямую системной памяти, а не кучи Java. Прямые объекты ByteBuffer можно передавать напрямую в функции системных библиотек ОС для осуществления ввода/вывода, что делает их в некоторых сценариях значительно быстрее, так как они могут избегать копирования данных между кучей Java и системной памятью.

С тем, где хранятся данные прямых объектов ByteBuffer, легко может возникнуть путаница. Приложение все также использует объект в куче Java для управления операциями ввода вывода, но сам буфер, хранящий данные, находится в системной памяти – а объект, находящийся в куче Java содержит только ссылку на этот буфер. Непрямой объект ByteBuffer хранит данные в массиве byte[] в куче Java. На рисунке 4 показана разница между прямыми и непрямыми объектами ByteBuffer:

Рисунок 4. Топология памяти прямых и непрямых объектов java.nio.ByteBuffer
ByteBuffer memory arrangements
Прямые объекты ByteBuffer очищают свои буферы системной памяти автоматически, но могут это делать только в рамках сборки мусора в куче Java, т.е. они не реагируют автоматически на сокращение количества системной памяти. Сборка мусора происходит только тогда, когда куча Java заполняется настолько, что не удается выполнить запрос на выделение памяти в куче или когда её явно запрашивает приложение Java (не рекомендуется, так как это вызывает проблемы производительности).

Возможно возникновение патологической ситуации, когда системная память заполняется и для одного или нескольких прямых буферов ByteBuffer могла бы быть выполнена сборка мусора (которая бы освободила некоторое количество системной памяти), однако куча памяти Java практически пуста и поэтому сборки мусора не происходит.

Потоки
Каждому потоку приложения требуется память для хранения его стека (области памяти, используемой для хранения локальных переменных и поддержания состояния при вызове функций). То есть, для работы каждого потока Java необходимо некоторое место в памяти. В зависимости от реализации поток Java может иметь раздельные системные и Java стеки. Помимо места для хранения стека каждому потоку требуется системная память для хранения локальных данных потока и внутренних структур данных.

Размер стека зависит от реализации Java и архитектуры. Некоторые реализации позволяют задавать размер стека потоков. Как правило, размер стека потока составляет от 256KB до 756KB.

Хотя количество памяти, используемое каждым потоком достаточно мало, для приложения с несколькими сотнями потоков общий объем используемой памяти может быть довольно велик. Запускать в приложении количество потоков, намного превышающее количество имеющихся процессоров, как правило, неэффективно. Приложение в таких случаях может работать с низкой производительностью и использовать много памяти.

Как я могу распознать нехватку системной памяти?
Исполняющая среда Java по-разному борется с ситуациями, когда заканчивается место в куче Java, и когда заканчивается системная память, хотя оба случая могут проявлять себя похожими симптомами. Приложение Java функционирует с очень большим трудом при исчерпании места в куче Java, так как приложению трудно что-либо сделать без создания объектов. Признаками исчерпания места в куче Java являются низкая производительность сборщика мусора и появление исключений OutOfMemoryError.

Но, когда приложение Java уже запустилось и находится в стабильном состоянии, оно может продолжать функционировать и с полностью исчерпанной системной памятью. Оно не обязательно будет показывать какое-либо странное поведение, так как действия, требующие выделения системной памяти происходят гораздо реже, чем действия, требующие выделения памяти в куче Java. В разных реализациях JVM выделение системной памяти требуется при различных действиях, однако в качестве популярных примеров можно привести: запуск потока, загрузку класса, а также определенные операции файлового и сетевого ввода/вывода.

Поведение системы при нехватке системной памяти не так однозначно, как при нехватке памяти в куче Java, так как не существует единого места управления выделением системной памяти. Если в куче Java все выделения памяти происходят под контролем системы управления памятью, то попытаться выделить системную память и получить ошибку может любой платформенно-зависимый код, находящийся внутри JVM, библиотек классов Java или кода приложения. Код, пытающийся выделить память, может обработать эту ошибку так, как захочет разработчик: может пробросить исключение OutOfMemoryError через интерфейс JNI, вывести сообщение об ошибке на экран, подождать и попробовать еще раз или сделать что-нибудь другое.

Недостаточная предсказуемость поведения в случае ошибки означает, что нет простого способа распознать исчерпание системной памяти. Поэтому для подтверждения догадки приходится пользоваться данными из ОС и исполняющей среды Java.

Примеры нехватки системной памяти
Чтобы помочь вам посмотреть, как ваша реализация Java реагирует на нехватку системной памяти, в примерах кода (см. Загрузки) приведено несколько программ Java, приводящих к нехватке системной памяти несколькими способами. Программы в примерах занимают все адресное пространство с помощью платформенно-зависимых библиотек, написанных на C, а затем пытаются выполнить какое-либо действие, требующее выделения системной памяти. Примеры поставляются в уже собранном виде, однако в html-файле README, находящемся в корневой директории каждого пакета, приводятся также инструкции по компиляции.

Класс com.ibm.jtc.demos.NativeMemoryGlutton содержит метод gobbleMemory(), который вызывает в цикле malloc до практически полного исчерпания системной памяти. По окончании своей работы он выводит в стандартный поток ошибок количество выделенных байт памяти:


При попытке обработать первое исключение OutOfMemoryError возникает второе исключение :OutOfMemoryError, ENOMEM error in ZipFile.open. Многократные исключения OutOfMemoryError часто встречаются при заполнении адресного пространства процесса. Возможно, самым распространенным признаком нехватки системной памяти является сообщение Failed to fork OS thread.

Примеры, поставляемые с этой статьей, генерируют массу исключений OutOfMemoryError Скорее всего, в ваших приложениях при нехватке системной памяти все будет выглядеть не так сурово. Отчасти, это связано с тем, что здесь заполняется практически вся системная память, и в отличие от реальных приложений она не освобождается впоследствии. В реальных приложениях при возбуждении исключения OutOfMemoryError закрываются потоки, что понижает давление на системную память и дает исполняющей среде шанс обработать ошибку. Тривиальная природа сценариев примеров также означает, что целые разделы библиотеки классов (например, система безопасности) не успевают проинициализироваться. Их инициализация начинается исполняющей средой Java при попытке обработать ситуацию нехватки системной памяти. В реальных приложениях вы, возможно, встретитесь с некоторыми из показанных здесь ошибок, однако маловероятно, что вы увидите их все вместе.

Исчерпание системной памяти на фазе загрузки JVM и рост потребления памяти, пропорциональный нагрузке, являются примерами того, как приложение пытается сделать слишком много в располагаемом пространстве. В этих сценариях у вас есть следующие варианты действий:

Уменьшить использование системной памяти Сокращение кучи Java – хорошая отправная точка.
Ограничить использование системной памяти. Если использование системной памяти возрастает при увеличении нагрузки, найдите способ оптимизировать нагрузку или механизм выделения ресурсов для новых заданий.
Увеличьте размер доступного адресного пространства. Это можно сделать, настроив ОС (например, увеличив пространство пользователя с помощью переключателя /3GB в Windows или переключившись на ядро hugemem в Linux), поменяв платформу (обычно Linux имеет больше пользовательского пространства, чем Windows) или перейдя на 64-разрядную операционную систему.
Настоящей утечкой системной памяти считается ситуация, когда объем используемой приложением системной памяти постоянно растет, причем память не освобождается даже после снижения нагрузки и работы сборщика мусора. Скорость утечки памяти может меняться в зависимости от нагрузки, но общее количество потерянной памяти никогда не сокращается. Маловероятно, что в приложении содержатся ссылки на блоки исчезнувшей памяти, поэтому она может быть перемещена в область подкачки, где будет храниться постоянно.

При обнаружении утечки у вас есть ограниченный набор возможных действий. Можно увеличить размер пользовательского пространства (чтобы выделить больше места, куда памяти можно утекать), но это лишь отсрочит время возникновения нехватки памяти. Если вы располагаете достаточным объемом физической памяти и адресного пространства, вы можете допустить существование утечки, при условии, что приложение будет перезагружаться до исчерпания всего адресного пространства процесса.

Что использует мою системную память?
Когда вы определили, что столкнулись с нехваткой системной памяти, возникает логичный вопрос: "что использует всю эту память"? Ответить на этот вопрос довольно сложно, так как Windows и Linux не хранят информации о том, каким именно кодом был выделен тот или иной участок памяти.

Первым шагом к пониманию того, куда ушла системная память, является оценка того, как много системной памяти должно использоваться приложением с текущими настройками Java. Сложно вычислить точное значение, не обладая глубокими знаниями работы JVM, но можно получить грубую оценку, руководствуясь следующими правилами:

Куча Java занимает не менее значения -Xmx.
Каждому потоку Java необходимо место для стека. Размер стека зависит от реализации, но с настройками по умолчанию каждый поток может занимать до 756КБ системной памяти.
Прямые объекты ByteBuffer занимают не менее памяти не меньше, чем указывается в вызове функции allocate().
Если полученное общее значение намного меньше размера пользовательского пространства, это не означает, что вы в безопасности. Многие другие компоненты окружения выполнения Java могут использовать достаточно памяти, чтобы вызвать проблемы. Однако если согласно вашим вычислениям вы приближаетесь к верхней границе пользовательского пространства, вполне вероятно, что вы столкнетесь с нехваткой системной памяти. Если вы подозреваете, что в вашем приложении есть утечка памяти, или хотите понять, куда именно уходит системная память, вам могут помочь несколько инструментов.

Microsoft предлагает инструменты UMDH (user-mode dump heap) и LeakDiag для отладки утечек системной памяти в Windows (см. Ресурсы). Оба инструмента работают похожим образом: записывают, какой код выделил каждый конкретный участок памяти, и предоставляют способ определить, каким кодом был выделен участок памяти, не освобожденный впоследствии. За инструкциями по использованию UMDH я рекомендую вам обратиться к статье Umdhtools.exe: How to use Umdh.exe to find memory leaks on Windows" (см. Ресурсы). А в этой статье я сфокусируюсь на том, как выглядит результат работы UMDH при проверке приложения с утечкой JNI.

В пакете примеров к данной статье имеется приложение Java, называемое LeakyJNIApp. В нем вызывается в цикле JNI метод с утечкой системной памяти. Программа UMDH делает снимок кучи системной памяти и трассировок системных стеков, показывающих, каким именно кодом был выделен каждый участок памяти. Сделав два таких снимка и проанализировав различия с помощью UMDH, можно получить отчет о росте использования системной памяти за данный интервал времени.

Отладчики уровня препроцессора. Для работы этих инструментов необходимо скомпилировать заголовок инструмента в тестируемый исходный код. Можно перекомпилировать собственные JNI библиотеки с одним из этих инструментов для отслеживания утечек памяти в вашем коде. Однако, подобные инструменты не могут найти утечки памяти внутри JVM, если у вас нет ее кода (и даже при наличии кода, скомпилировать подобный инструмент в такой большой проект как JVM наверняка будет сложной и трудоемкой задачей). Примером подобного инструмента является Dmalloc (см. Ресурсы).
Отладчики цуровня компоновщика. В таких инструментах требуется перекомпоновка бинарных файлов с отладочной библиотекой. Как и инструменты предыдущей категории, эти инструменты подходят для работы с отдельными JNI библиотеками, но не годятся для всей исполняющей среды Java, так как вряд ли производитель исполняющей среды поддерживает возможность запуска модифицированных бинарных файлов. Примером инструмента такого рода является ccmalloc (см. Ресурсы).
Отладчики уровня компоновщика исполняемой среды. В этих инструментах используется переменная окружения LD_PRELOAD для предварительной загрузки библиотеки, заменяющей стандартные процедуры работы с памятью инструментированными версиями. Эти инструменты не требуют повторной компиляции или компоновки исходного кода, но многие из них плохо работают с исполняющими средами Java. Исполняющая среда Java – сложная система, которая может использовать память и потоки необычными способами, что может вводить в заблуждение подобные инструменты. Стоит поэкспериментировать с одним или несколькими подобными инструментами, чтобы посмотреть, будут ли они работать в ваших сценариях. Примером инструмента такого рода является NJMAD (см. Ресурсы).
Отладчики, основанные на эмуляторах. Модуль memcheck инструмента Valgrind – единственный представитель отладчиков памяти этого типа (см. Ресурсы). Он эмулирует процессор подобно тому, как исполняющая среда Java эмулирует виртуальную машину (JVM). Под ним можно запускать Java, однако сильное снижение производительности (в 10-30 раз) делает весьма затруднительным запуск подобным образом больших и сложных приложений Java. В настоящее время Valgrind доступен на Linux x86, AMD64, PPC 32 и PPC 64. Если вы используете Valgrind, попытайтесь предварительно сузить проблему до наименьшего возможного сценария (по возможности исключив из него всю среду выполнения Java).
Для простых сценариев, в которых падение производительности приемлемо, memcheck из Valgrind является самым простым и дружелюбным среди доступных бесплатных инструментов. Так же как UMDH в Windows, он может предоставить полную трассировку стека кода, в котором происходит утечка памяти.

Приложение LeakyJNIApp является достаточно простым для того, чтобы запускать его под Valgrind. Модуль memcheck из Valgrind по окончании выполнения программы может распечатывать сводную информацию об утечках памяти. По умолчанию, программа LeakyJNIApp выполняется бесконечно, чтобы она завершилась по истечении определенного времени, нужно передать желаемое время выполнения в секундах в виде аргумента командной строки.

Некоторые исполняющие среды Java используют стеки потоков и регистры процессора нестандартными способами. Это может вводить в заблуждение некоторые инструменты отладки, которые полагают, что программы работают согласно стандартным соглашениям об использовании регистров и стековых структур. При использовании Valgrind для отладки утечек памяти в приложениях JNI вы можете заметить много предупреждений об использовании памяти, также некоторые стеки потоков будут выглядеть странными. Не беспокойтесь об этом, это связано с тем, каким образом исполняющая среда Java структурирует свои данные.

 
Для отладки утечек системной памяти также имеется несколько коммерческих инструментов с закрытым кодом. Постоянно появляются новые инструменты (как с открытым, так и закрытым кодом) и вам перед выбором инструмента стоит изучить состояние дел в этой области на текущий момент.

В настоящее время отладка утечек системной памяти в Linux с помощью бесплатных инструментов является, по сравнению с Windows, более трудной задачей. В то время как UMDH позволяет отлаживать утечки системной памяти в Windows in situ (от начала и до конца), на Linux, возможно, стоит провести традиционную отладку, а не полагаться на то, что инструмент решит проблему за вас. Вот некоторые предлагаемые нами шаги отладки:

Выявите сценарий. Создайте отдельное окружение, в котором вы можете воспроизводить утечку системной памяти. Это существенно упростит отладку.
Сократите сценарий насколько это возможно. Пробуйте заменять функции заглушками, чтобы идентифицировать участок кода, виновный в утечке памяти. Если у вас есть собственные JNI библиотеки, также попробуйте заменить их заглушками, чтобы определить, не в них ли причина утечки.
Сократите размер кучи Java. Вероятно, что куча Java является самым крупным потребителем виртуального адресного пространства процесса. Сократив размер кучи Java, вы можете освободить некоторое количество системной памяти для других нужд.
Отслеживайте изменение размера процесса. Имея график изменения использования системной памяти с течением времени, можно сопоставить его с данными о нагрузке приложения и сборке мусора. Если скорость утечки пропорциональна уровню нагрузки, можно предположить, что утечка вызвана чем-то, что происходит при каждой транзакции или операции. Если размер памяти процесса значительно падает после сборки мусора, можно предположить, что вы имеете дело не с утечкой, а с созданием объектов, для которых выделяется системная память (например, объектов ByteBuffer). Количество памяти, занимаемое объектами, использующими системную память, можно уменьшить, сократив размер кучи Java (таким образом, заставляя более часто запускать сборку мусора) или самостоятельно организовав для них некий кэш объектов, вместо того, чтобы полагаться при их удалении на сборщика мусора.
Если вы идентифицировали утечку памяти или рост использования памяти, которые происходят, по вашему мнению, внутри самой исполняющей среды Java, возможно следует предложить производителю окружения выполнения расследовать эту проблему.

Устраняем ограничения: переход на 64-разрядную ОС
В 32-разрядной среде выполнения Java довольно просто исчерпать всю системную память, так как адресное пространство относительно мало. Пользовательское пространство от 2 до 4ГБ, предоставляемое 32-разрядными ОС зачастую меньше объема имеющейся физической памяти и многие современные приложения, работающие с большими объемами данных, могут легко заполнить все доступное пространство.

Если ваше приложение не может поместиться в 32-разрядном адресном пространстве, можно многократно увеличить размер пользовательского пространства, перейдя на 64-разрядную исполняющую среду Java. При работе на 64-разрядной ОС 64-разрядная исполняющая среда Java позволяет использовать огромные кучи памяти Java и забыть о проблемах с нехваткой места в адресном пространстве. 
Тем не менее, переход на 64-разрядную систему не является универсальным решением для всех проблем, связанных с системной памятью, Вам все так же нужно иметь достаточное количество физической памяти для хранения всех ваших данных. Если исполняющая среда Java не будет помещаться в физической памяти, производительность приложения будет неприемлемо низкой, так как ОС будет вынуждена постоянно копировать данные в область подкачки и из нее. По той же причине переход на 64-разрядную систему не является решением проблемы утечки памяти – вы просто предоставляете больше места, куда память может утекать, покупая своему приложению отсрочку перед вынужденной перезагрузкой.

Не всегда возможно использовать 32-разрядный платформенно-зависимый код в 64-разрядной исполняющей среде; любой платформенно-зависимый код (библиотеки JNI, агенты интерфейса инструментов JVM (JVM Tool Interface или JVMTI), интерфейса профилирования JVM (JVM Profiling Interface или JVMPI) и интерфейса отладки JVM (JVM Debug Interface или JVMDI)) должны быть перекомпилированы для 64-разрядной среды. Производительность 64-разрядной исполняющей среды также может быть ниже, чем производительность аналогичной 32-разрядной версии на том же железе. 64-разрядная исполняющая среда использует 64-разрядные указатели (ссылки на адреса системной памяти), поэтому объект в 64-разрядной исполняющей среде занимает больше места, чем, объект, содержащий те же самые данные в 32-разрядной среде. Больший размер объектов означает, что для хранения того же объема данных в куче Java требуется больше места, при одинаковой производительности сборщика мусора. Это делает кэши аппаратного обеспечения и ОС менее эффективными. К удивлению, больший размер кучи Java не обязательно означает более долгую работу сборщика мусора, так как количество "живых" данных в куче может и не увеличиться, поэтому некоторые алгоритмы сборки мусора более эффективны с большими кучами Java.

В некоторых современных исполняющих средах Java имеются технологии для для уменьшения "распухания" 64-разрядных объектов и улучшения производительности. Такая функциональность работает за счет использования более коротких ссылок в 64-разрядных исполняющих средах. Это называется сжатыми ссылками в реализациях от IBM и сжатыми объектами (oops) в реализациях от Sun.

Сравнительный анализ производительности исполняющих сред Java выходит за пределы данной статьи. Однако можно сказать, что если вы рассматриваете возможность перехода на 64-разрядную систему, стоит пораньше протестировать ваше приложение, чтобы оценить его производительность. Так как изменение размера адресного пространства влияет на кучу Java, вам следует перенастроить параметры сборщика мусора на новой архитектуре, а не просто перенести существующие настройки.

Заключение
Понимание устройства системной памяти играет важную роль при проектировании и написании больших Java-приложений. Этим часто пренебрегают, так как чтобы его понять, приходится вникать в детали работы аппаратного обеспечения и ОС, от которых исполняющая среда Java по замыслу должна нас изолировать. Однако JRE – это процесс, который должен работать в окружении, определяемом этими деталями. Чтобы выжать максимум производительности из своего Java-приложения, необходимо понимать, как приложение влияет на использование системной памяти в исполняющей среде.

Нехватка системной памяти может походить на нехватку памяти в куче Java, но для отладки и решения проблем с нехваткой системной памяти необходим другой набор инструментов. Ключевыми факторами в устранении неполадок с системной памятью являются понимание того, какие ограничения накладываются на системную память со стороны аппаратного обеспечения и ОС, на которых работает ваше Java-приложение, и умение работать с инструментами ОС для отслеживания использования системной памяти. Комбинируя эти знания и умения вы сможете решать одни из самых сложных задач, которые могут возникнуть в ваших Java-приложениях.